# Design Pattern课程项目——世界杯

第33组“抽象小卖部”的小组成员及分工情况为：...

# 1. 题材综述

本项目的选题为卡塔尔世界杯。项目共分为了世界杯开幕前的准备和建设阶段、世界杯开幕式阶段、世界杯小组赛和淘汰赛等比赛期间和其他场景四个阶段，每个阶段都包含多个设计模式。

在世界杯开幕前的准备和建设阶段，举办方建造场馆时，使用工厂模式，根据不同客户的需求，生产不同的物流工具，并统计参赛队员的信息，如年龄性别等。同时，我们也统计中国的各种人员是否有到来，比如中国的足球队、中国的施工队等。场馆的建造代价是高昂的，因此我们采用惰性初始模式，先拖延建造，直到有需求时再建造。世界杯的足球花样繁多，不容易单独制造，因此我们采用原型模式克隆。不同的出发地点对应不同的路线选择。

在世界杯开幕式阶段，各个参赛国家代表团依次在卡塔尔会场登记。球员抵达比赛地点，开始入住酒店。开幕式时显示若干球员的生平信息，类似于基本介绍。在入住酒店的过程中，雇工开始为运动员搬运行李。

在世界杯小组赛和淘汰赛等比赛期间，为了解决语言交流问题，卡塔尔主办方已向各个国家参赛队伍队派遣了志愿翻译。赛程安排结束，各球员关心自己的比赛赛程，向资料库发出查看申请，对不同申请作出不同回应，显示各自赛程。同时，每场比赛开始时，展示明星球员的信息。开幕式结束后，准备开始正式的比赛，此时用于生成每一场比赛对应的时间、国家、裁判组等信息。比赛过程中若是出现球员上诉，则用责任链模式处理球员上诉。世界杯比赛赛制繁多，采用享元模式对比赛类型进行添加设置。每场比赛结束后，根据两队是否还有剩余的比赛来决定是否保留国旗与队服。

卡塔尔世界杯期待各国足球队伍的参与和各国球迷的观看！

# 2. Design Pattern 汇总表

|      | 设计模式                          |      | 设计模式                         |
| ---- | --------------------------------- | ---- | -------------------------------- |
| 1    | Servant(雇工模式)                 | 18   | TemplateMethod(模板方法模式)     |
| 2    | ChainOfResponsibility(责任链模式) | 19   | RAII(资源获取即初始化)           |
| 3    | Facade(外观模式)                  | 20   | State(状态模式)                  |
| 4    | Visitor(访问者模式)               | 21   | Flyweight(享元模式)              |
| 5    | State(状态模式)                   | 22   | Proxy(代理模式)                  |
| 6    | Flyweight(享元模式)               | 23   | BlackBoard(黑板模式)             |
| 7    | Proxy(代理模式)                   | 24   | AbstractFactory(抽象工厂模式)    |
| 8    | BlackBoard(黑板模式)              | 25   | Builder(生成器模式)              |
| 9    | Command(命令模式)                 | 26   | Bridge(桥接模式)                 |
| 10   | Interpreter(解释器模式)           | 27   | ObjectPool(对象池模式)           |
| 11   | Null object(空对象模式)           | 28   | Mediator(中介者模式)             |
| 12   | Transfer object(传输对象模式)     | 29   | Memento(备忘录模式)              |
| 13   | FactoryMethod(工厂模式)           | 30   | Observer(观察者模式)             |
| 14   | Prototype(原型模式)               | 31   | Publish-Subscribe(发布订阅模式)  |
| 15   | Lazy Initialization(惰性初始模式) | 32   | Singleton(单例模式)              |
| 16   | Iterator(迭代器模式)              | 33   | Front Controller(前端控制器模式) |
| 17   | Adapter(适配器模式)               |      |                                  |

# 3. Design Pattern 详述

##  Servant(雇工模式)

### 模式简介

雇工模式（Employee Pattern）也叫作仆人模式（Servant Pattern），属于行为型设计模式，它为一组类提供通用的功能，而不需要类实现这些功能，也是命令模式的一种扩展。

### 应用场景

雇工模式可以被用来完成多个相似类的同种功能，而无需这些类自行去完成，所以雇工模式可以用来为球员搬运行李，球员无需考虑行李的类型大小，只要交给雇工即可，雇工类可以完成所有物品类的搬运工作。

### Class Diagram

![img](Document.assets/(null)-20230113171918341.(null))

## ChainOfResponsibility(责任链模式)

### 模式简介

责任链模式是一种行为设计模式， 允许将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。

### 应用场景

因为责任链模式允许将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者，所以责任链模式可以用于处理球员申诉，球员的申诉有的只需要现场的处理，有的却需要较高层的人员来做决定，所以通过责任链模式，对于上诉层层上交，每个球员的申诉都可以在合适的层级被处理。

### Class Diagram

![img](Document.assets/(null)-20230113171919181.(null))

## Facade(外观模式)

### 模式简介

外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。

### 应用场景

外观模式可以为复杂的类提供一个简单的接口，所以外观模式可以用于处理球员入住的复杂问题，球员入住本身是一个极为复杂的过程，而通过外观模式，球员只需要在几个关键的部分做出行动，就可以完成入住，复杂的流程则被封装到不可见。

### Class Diagram

![img](Document.assets/(null)-20230113171918187.(null))

## Visitor(访问者模式)

### 模式简介

访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

### 应用场景

访问者模式由于可以快速的根据访问的对象来改变方法，故访问者模式可以用于在比赛过程中播报比赛，播报类连续接收多个不同的比赛类，通过调整自身使用的方法来正常播报每一场比赛。

### Class Diagram

![img](Document.assets/(null)-20230113171918154.(null))

## State(状态模式)

### 模式简介

​      状态模式是一种行为设计模式， 能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。状态模式建议为对象的所有可能状态新建一个类， 然后将所有状态的对应行为抽取到这些类中。原始对象被称为*上下文* （context）， 它并不会自行实现所有行为， 而是会保存一个指向表示当前状态的状态对象的引用， 且将所有与状态相关的工作委派给该对象。如需将上下文转换为另外一种状态， 则需将当前活动的状态对象替换为另外一个代表新状态的对象。 采用这种方式是有前提的:所有状态类都必须遵循同样的接口， 而且上下文必须仅通过接口与这些对象进行交互。

### 应用场景

状态模式是让一个对象在其内部状态改变的时候，其行为也随之改变。故状态模式可以用来处理比赛过程中,随着比赛的进行，赛制状态的不断转变，从小组赛到淘汰赛再到决赛，通过Context的不断转变，达到内部状态改变的目的，从而使行为改变。

### Class Diagram

![img](Document.assets/(null)-20230113171918076.(null))

## Flyweight(享元模式)

### 模式简介

​      享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 能在有限的内存容量中载入更多对象。享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。 这些对象的区别仅在于其内在状态 （与外在状态相比， 内在状态的变体要少很多）， 因此所需的对象数量会大大削减。

### 应用场景

享元模式使用物件用来尽可能减少内存使用量；于相似物件中分享尽可能多的资讯。当大量物件近乎重复方式存在，因而使用大量内存时，此法适用。通常物件中的部分状态(state)能够共享。常见做法是把它们放在数据结构外部，当需要使用时再将它们传递给享元。在比赛过程中，赛程的制定以及赛程的安排，可以借助此模式，来对比赛的赛程赛制进行制定与添加。

### Class Diagram

![img](Document.assets/(null)-20230113171918323.(null))

## Proxy(代理模式)

### 模式简介

​      代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。

### 应用场景

当一个复杂对象的多份副本须存在时，代理模式可以减少存储器用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。因此，在比赛进行过程中，有许多机构需要查询球员药检结果，如果每个机构都去联系药检中心，则会使过程繁杂，复杂对象不断被调用，因此创建一个中介对象，机构通过对中介的联系，来联系药检中心，进而完成药检结果的查询。

### Class Diagram

![img](Document.assets/(null))

## BlackBoard(黑板模式)

### 模式简介

​      黑板模式是一种常用的架构模式，应用中的多种不同数据处理逻辑相互影响和协同来完成数据分析处理。就好像多位不同的专家在同一黑板上交流思想，每个专家都可以获得别的专家写在黑板上的信息，同时也可以用自己的分析去更新黑板上的信息，从而影响其它专家。

### 应用场景

黑板模式的应用场景是要解决的任务可以分为多个子任务。本项目中，将针对各国球员查询本国赛程时，返回不同的信息进行黑板模式的运用，以达到不同国家球员查询返回不同信息的功能。

### Class Diagram

![img](Document.assets/(null)-20230113171918245.(null))

## Command(命令模式)

### 模式简介

将请求封装为一个对象，从而允许对具有不同请求的客户端进行参数化，以及对请求进行排队或记录。它还允许支持可撤销的操作。

### 应用场景

命令模式可以将命令进行抽象操作，通过声明泛化类来实现特定的操作，同时，由于在请求发送者的类中有记录请求的信息，所以实现了撤回的操作。将进球得分的命令定义为抽象类，分别定义头球、射门、远射泛化类，通过调用不同的泛化类来进行得分方式的记录以及比分的记录，如果出现误操作，那么也可以进行撤回操作。

### Class Diagram

![img](Document.assets/(null)-20230113171918309.(null))

## Interpreter(解释器模式)

### 模式简介

给定一种语言，定义其语法的表示以及使用该表示来解释该语言中的句子的解释器。

### 应用场景

解释器模式可以通过定义一种特殊的语法来提取语句中的信息。所以在探讨中国的哪些人员来到世界杯现场的问题中，可以通过定义解释器来提取语句的关键信息，比如“中国的裁判”，提取出“中国”以及“裁判”，得到的结果是来到了世界杯现场。

### Class Diagram

![img](Document.assets/(null)-20230113171918401.(null))

## Null object(空对象模式)

### 模式简介

通过提供默认对象避免空引用。

### 应用场景

空对象模式可以在无法创建具体实例或数据不可用时提供默认行为，而不是一个NULL值。所以空对象模式可以用于查找并返回球员的个人生平，球员抽象类有两个泛化类，一个是具体的球员类，一个是空对象类。如果预置数据中含有该球员，则成功生成一个具体球员类，返回其信息；如果预置数据中没有该球员，则生成一个空对象类，返回的是“信息不存在”的消息。

### Class Diagram

![img](Document.assets/(null)-20230113171918391.(null))

## Transfer object(传输对象模式)

### 模式简介

从客户端到服务端一次性传递带有多个属性的数据。

### 应用场景

传输对象模式可以通过创建具有setter/getter函数的实体VO类来封装类数据以及一个实体BO类来进行具体操作。所以传输对象模式可以用来动态统计各国家观众人数，通过在BO中定义函数来实现对数据库的操作，使之符合观众人数的变化情况，做到动态统计观众人数。

### Class Diagram

![img](Document.assets/(null)-20230113171918484.(null))

## FactoryMethod(工厂模式)

### 模式简介

工厂方法模式在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

### 应用场景

在卡塔尔建造场馆的过程中，工人需要从世界各地运输而来的物资，但是作为客户端，关注具体的运输方法（轮船、飞机等）是耗费精力的，工厂模式可以让客户端将所有物流都视为抽象的运输，而无需关心其具体实现。

### Class Diagram

![img](Document.assets/(null)-20230113171918580.(null))

## Prototype(原型模式)

### 模式简介

原型模式将克隆过程委派给被克隆的实际对象。

### 应用场景

所有的类对克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。世界杯的足球都经过精心设计，单从外部难以全部复制，通过克隆的方法，可以很好地避免这种问题。

### Class Diagram

![img](Document.assets/(null)-20230113171918710.(null))

## Lazy Initialization(惰性初始模式)

### 模式简介

惰性初始是一种拖延战术。在第一次需求出现以前，先延迟创建物件、计算值或其它昂贵程序。

### 应用场景

建造场馆需要高昂的代价，因此不直接建造场馆，而是先拖延建造，直到有需求时再建造，这样可以减少经费的开支。

### Class Diagram

![img](Document.assets/(null)-20230113171918644.(null))

## Iterator(迭代器模式)

### 模式简介

提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。

### 应用场景

每个参赛国家都需要在截止时间前提交参赛人员的名单，还需要进行现场登记。为了保护每个国家队伍的隐私，登记结果显示就可以使用Iterator(迭代器)模式，只显示并且以此显示每个国家队伍的登记顺序和参赛人员数量。

### Class Diagram 

![img](Document.assets/(null)-20230113171918597.(null))

## Adapter(适配器模式)

### 模式简介

将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。

### 应用场景

每个参赛国家队伍之间一定会有交流，但由于队伍来自世界多个国家，所使用的官方语言也不尽相同，为了更加便利与球员交流，卡塔尔主办方已向各个国家参赛队伍队派遣了志愿翻译，可以将其他语言翻译为该队伍使用的官方语言，这便运用到了适配器模式，使球员可以实现顺利交流。

### Class Diagram 

![img](Document.assets/(null)-20230113171918734.(null))

## TemplateMethod(模板方法模式)

### 模式简介

模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。

### 应用场景

世界杯比赛流程大致可分为：小组赛，半决赛，决赛等赛程，每场比赛都可以是一个赛事地点+比赛双方模板的运用。因此这里便采用了模板方法模式，每场比赛都运用比赛类下的模板方法。

### Class Diagram 

![img](Document.assets/(null)-20230113171918618.(null))

## RAII(**资源获取即初始化**)

### 模式简介

通过绑定到合适对象的生命周期来确保资源被适当地释放。

### 应用场景

每场比赛开始时，球场都是初始化状态，且该球场会被比赛占用。每场比赛结束后，球场都会被清理干净，并且解除占用状态。这十分符合资源获取即初始化模式。

### Class Diagram 

![img](Document.assets/(null)-20230113171918887.(null))

## AbstractFactory(抽象工厂模式）

### 模式简介

​       工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

- 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。
- 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。
- 为每种产品变体实现一个具体工厂类。

### 应用场景

​       正式比赛开始前，生产每个国家队的国旗和球衣。可以看作准备阶段的工作，也可以看作每一场具体比赛开始之前的工作，请根据模式数目情况决定具体放在哪个场景中。

### Class Diagram

![img](Document.assets/(null)-20230113171918753.(null))

## Builder(生成器模式)

### 模式简介

​       生成器模式，能够分步骤创建复杂对象。 允许使用相同的创建代码生成不同类型和形式的对象。基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。

### 应用场景

​       每一场比赛的举办，使用生成器模式（建造者模式）实现。**定义抽象的比赛生成器**，不同场次的比赛类继承生成器，实现具体的比赛信息，包括**时间、国家、裁判组**等。开幕式结束后，准备开始正式的比赛，此时用于生成每一场比赛对应的时间、国家、裁判组等信息。

### Class Diagram

![img](Document.assets/(null)-20230113171918797.(null))

## Bridge(桥接模式)

### 模式简介

​       抽象类中抽离出实现接口，形成桥接关系，避免增加成员属性带来的繁重类添加工作。

### 应用场景

​       对于每个国家队的明星或关键球员进行补充信息展示，包括**现役俱乐部，参与世界杯次数，金球奖荣誉情况**等。每场比赛开始时，展示明星球员的信息。

### Class Diagram

![img](Document.assets/(null)-20230113171919173.(null))

## ObjectPool(对象池模式)

### 模式简介

​       一个**对象池**包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。

### 应用场景

​       **此模式可以与抽象工厂协作，**在每一场比赛结束后，并不会立即销毁生产国旗和球衣的工厂，而是将其加入对象池，在相应队伍的下一场比赛时重新启动。每场比赛结束后，根据两队是否还有剩余的比赛来决定是否保留国旗与队服。

### Class Diagram

![img](Document.assets/(null)-20230113171919123.(null))

## Mediator(中介者模式)

###  模式简介

**中介者模式**是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个**中介者对象**进行合作。

###  应用场景

90到120分钟的足球赛对球员的体力消耗是巨大的，往往球员在后半场的表现会很受影响。主教练也需要权衡每位球员的状态，规划有限的替换球员的机会。

**球员**之间并不通过直接交互协调，而是通过**主教练**(中介者完成)

###  Class Diagram

![img](Document.assets/(null)-20230113171918919.(null))

## Memento(备忘录模式)

###  模式简介

**备忘录模式**是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

文字编辑器应用中的撤销(undo)操作是备忘录模式的典型应用。

![img](Document.assets/(null)-20230113171919157.(null))

###  应用场景

2022年卡塔尔世界杯将启用半自动越位识别技术(SAOT)，11月22日，阿根廷在对阵沙特阿拉伯的比赛中，3粒进球被SAOT系统判定为越位，最终爆冷1:2负于沙特阿拉伯。

在被判定为越位后，得分需要被重做到之前的状态，此时就要采用备忘录模式。

### Class Diagram

![img](Document.assets/(null)-20230113171919063.(null))

## Observer(观察者模式)

###  模式简介

**观察者模式**是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “**观察**” 该对象的其他对象。

![img](Document.assets/(null)-20230113171919086.(null))

###  应用场景

热情的球迷们和媒体涌向卡塔尔世界杯比赛现场观战，全神贯注的球迷总能第一时间捕获赛事动向，如果走神的话可能就会错失精彩场面。

因此在出现赛事进展的时候，现场的"**观察者**"能够立刻获取，而非观察者则不能。

###  Class Diagram

![img](Document.assets/(null)-20230113171919231.(null))

## Publish-Subscribe(发布-订阅模式)

###  模式简介

**发布-订阅模式**是一种使应用程序能够以异步方式向多个感兴趣的使用者公布事件，而无需将发送方与接收方耦合的架构模式。

发布订阅模式里，发布者和订阅者，不是**松耦合**，而是完全**解耦**的。

###  应用场景

很多球迷因为种种原因，不能亲眼见证比赛，于是他们通过订阅一些频道，获取他们感兴趣的赛事进展。

赛事信息(Publisher)首先进入频道，在不和订阅者直接接触的情况下通过频道(Channel)发送给有需要的订阅者(Subscriber)。

###  Class Diagram

![img](Document.assets/(null)-20230113171919429.(null))

## Front Controller(前端控制器模式)

###  模式简介 

**前端****控制器模式**（Front Controller Pattern）是一个用来提供统一的请求处理的机制。所有的请求都由一个统一的处理程序进行处理，该处理程序可以做权限认证，也可以对请求进行跟踪。

前端控制器模式起到一个类似网关的作用，接收各个来源的请求并作鉴权追踪处理，最后统一由控制器中的调度器处理请求。该设计模式用于设计课程项目的总体框架上，控制器接收各个设计模式参数，并由调度器调用相应的测试函数进行测试。

前端控制器模式具有三个主要优势：

- 集中控制
- 线程安全
- 可配置性

###  应用场景

项目完成了世界杯从初期筹备建设，到开幕盛景，再到正式比赛万人同场，球员在绿茵场上奋力争夺大力神杯，设计的每一个场景都需要有序、可靠地被展示，各个设计模式之间也要保证高耦合、低内聚，因此选用前端控制器模式，能够有效的保证代码易于维护，能够被集中控制，原本复杂的应用程序的配置，也被大大简化，代码迭代更新更加方便。

###  Class Diagram

![img](Document.assets/(null)-20230113171919230.(null))

## Singleton(单例模式)

###  模式简介

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

- 单例模式同时解决了两个问题：

- - **保证一个类只有一个实例**
  - **为该实例提供一个全局访问节点**

###  应用场景

- 对得分排名使用单例模式，在访问得分排名时，访问其一个特定实例
- 整场世界杯赛事中，得分排行无疑是唯一的，因此使用单例模式避免的构造多个对象产生的资源浪费。

###  Class Diagram

![img](Document.assets/(null)-20230113171919416.(null))

## Strategy(策略模式)

### 模式简介

策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

### 应用场景

不同国家的队员需要通过各种方式到达卡塔尔，我们的程序需要为不同国家的代表团规划路线，然后将其中的算法抽取到一组策略的独立类中。

### Class Diagram

![img](Document.assets/(null)-20230113171919444.(null))

## Compose(组合模式)

### 模式简介

**组合**是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。

### 应用场景

为前来参赛的队员提供礼包，在礼包里面的物品可以使用组合模式。

### Class Diagram

![img](Document.assets/(null)-20230113171919374.(null))

## Decorator(装饰模式)

### 模式简介

**装饰模式**是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

### 应用场景

为每一个球员动态地生成一个自定义的虚拟的3d头像。

### Class Diagram

![img](Document.assets/(null)-20230113171919382.(null))

## Filter(过滤模式)

### 模式简介

过滤器模式使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。

### 应用场景

检测球员的基本信息并进行统计。

### Class Diagram

![img](Document.assets/(null)-20230113171919575.(null))

# 4. 参考文献

[1] Deepak Alur, Dan Malks, John Crupi . Core J2EE Patterns: Best Practices and Design Strategies. Prentice Hall PTR, 2003. 395-397.

[2] M. Birbeck. Professional XML. Beijing: Machine Press, 2002. 14-16

[3] Robert Nystrom.Game Programming Patterns[M]ISBN: 978-0-9905829-0-8,2004,291

[4] William Crawford, Jonathan Kaplan. J2EE Design Patterns - Patterns in the Real World.[M]DBLP:William Crawford,2003.37:50

[5] Grand M . Patterns in Java: A  of Reusable Design Patterns Illustrated with UML, 2nd Edition, Volume 1[J]. computer bookshops, 2002, 21(9):153-162.